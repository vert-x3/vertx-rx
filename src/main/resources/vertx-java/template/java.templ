@comment{"This is where the generation starts"}
@comment{"==================================="}

/*\n
 * Copyright 2014 Red Hat, Inc.\n
 *\n
 * Red Hat licenses this file to you under the Apache License, version 2.0\n
 * (the "License"); you may not use this file except in compliance with the\n
 * License.  You may obtain a copy of the License at:\n
 *\n
 * http://www.apache.org/licenses/LICENSE-2.0\n
 *\n
 * Unless required by applicable law or agreed to in writing, software\n
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT\n
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n
 * License for the specific language governing permissions and limitations\n
 * under the License.\n
 */\n\n

package @{ifacePackageName.replace("io.vertx.", "io.vertx.java.")};\n

@comment{'the current index of the cache'}
@code{cacheDecls=new java.util.ArrayList()}


@declare{'invokeDelegate'}
@if{method.staticMethod}@{helper.getNonGenericType(ifaceFQCN)}@else{}@includeNamed{'rewriteDelegate';method=method}@end{}.@{method.name}(@foreach{param: method.params}@includeNamed{'paramArgument';param=param}@end{', '})
@end{}

@declare{'rewriteDelegate'}
@if{method.ownerTypes.size() > 1}
( /* Work around for https://jira.codehaus.org/browse/GROOVY-6970 */ (@{method.ownerTypes.iterator().next().name}) delegate)
@else{}
this.delegate
@end{}
@end{}

@declare{'paramTemplate'}
	@if{param.type.kind == OPTIONS || param.type.kind == JSON_OBJECT}
		Map<String, Object> @{param.name}
	@else{param.type.kind == JSON_ARRAY}
		List<Object> @{param.name}
	@else{param.type.kind == HANDLER && param.type.args[0].kind.json}
		@if{param.type.args[0].kind == JSON_OBJECT}
			@code{groovyJsonType='Map<String, Object>'}
		@else{}
			@code{groovyJsonType='List<Object>'}
		@end{}
		Handler<@{groovyJsonType}> @{param.name}
	@else{param.type.kind == HANDLER && param.type.args[0].kind == JSON_ARRAY}
		Handler<List<Object>> @{param.name}
	@else{param.type.kind == HANDLER && param.type.args[0].kind == LIST && param.type.args[0].args[0].kind.json}
		@if{param.type.args[0].args[0].kind == JSON_OBJECT}
			@code{groovyJsonType='Map<String, Object>'}
		@else{}
			@code{groovyJsonType='List<Object>'}
		@end{}
		Handler<List<@{groovyJsonType}>> @{param.name}
	@else{param.type.kind == HANDLER && param.type.args[0].kind == ASYNC_RESULT && param.type.args[0].args[0].kind.json}
		@if{param.type.args[0].args[0].kind == JSON_OBJECT}
			@code{groovyJsonType='Map<String, Object>'}
		@else{}
			@code{groovyJsonType='List<Object>'}
		@end{}
		Handler<AsyncResult<@{groovyJsonType}>> @{param.name}
	@else{param.type.kind == HANDLER && param.type.args[0].kind == ASYNC_RESULT && param.type.args[0].args[0].kind.collection && param.type.args[0].args[0].args[0].kind.json}
		@if{param.type.args[0].args[0].args[0].kind == JSON_OBJECT}
			@code{groovyJsonType='Map<String, Object>'}
		@else{}
			@code{groovyJsonType='List<Object>'}
		@end{}
		Handler<AsyncResult<@{param.type.args[0].args[0].raw.simpleName}<@{groovyJsonType}>>> @{param.name}
	@else{}
		@{param.type.simpleName} @{param.name}
	@end{}
@end{}

@declare{'resultHandlerTemplate'}
	new Handler<AsyncResult<@{eventJavaType}>>() {\n
	      public void handle(AsyncResult<@{eventJavaType}> event) {\n
	        AsyncResult<@{eventGroovyType}> f\n
	        if (event.succeeded()) {\n
	          f = InternalHelper.<@{eventGroovyType}>result(@{callbackObject})\n
	        } else {\n
	          f = InternalHelper.<@{eventGroovyType}>failure(event.cause())\n
	        }\n
	        @{callbackName}.handle(f)\n
	      }\n
	    }
@end{}

@declare{'paramArgument'}
	@if{param.type.kind == OPTIONS}
		new @{param.type.name}(new io.vertx.core.json.JsonObject(@{param.name}))
	@else{param.type.kind.json}
		new @{param.type.name}(@{param.name})
	@else{param.type.kind == API}
		@{param.name}.delegate
	@else{param.type.kind == OBJECT}
		InternalHelper.unwrapObject(@{param.name})
	@else{param.type.kind == HANDLER}
		@code{eventType=param.type.args[0]}
		@code{eventKind=eventType.kind}
		@if{eventKind == OTHER || eventKind.basic || eventKind == VOID || eventKind == THROWABLE}
			@{param.name}
		@else{eventKind == JSON_OBJECT}
			new Handler<JsonObject>() {\n
			      public void handle(JsonObject event) {\n
			        @{param.name}.handle(event.toMap());\n
			      }\n
			    }
		@else{eventKind == JSON_ARRAY}
			new Handler<JsonArray>() {\n
			      public void handle(JsonArray event) {\n
			        @{param.name}.handle(event.toList());\n
			      }\n
			    }
		@else{eventKind == LIST || eventKind == SET}
			@code{elementType=eventType.args[0]}
			@code{elementKind=elementType.kind}
			@if{elementKind == PRIMITIVE || elementKind == BOXED_PRIMITIVE || elementKind == STRING}
				@{param.name}
			@else{elementKind == API || elementKind.json}
				@code{collectionName=eventType.raw.simpleName}
				@if{elementKind == API}
					@code{toGroovyElement='new ' + elementType.simpleName + '(it)'}
					@code{elementJavaType=elementType.name}
				@else{elementKind == JSON_OBJECT}
					@code{toGroovyElement='it.toMap()'}
					@code{elementJavaType='JsonObject'}
				@else{}
					@code{toGroovyElement='it.toList()'}
					@code{elementJavaType='JsonArray'}
				@end{}
				new Handler<@{collectionName}<@{elementJavaType}>>() {\n
				      public void handle(@{collectionName}<@{elementJavaType}> event) {\n
				        @{param.name}.handle(event.collect({\n
				          @{toGroovyElement}\n
				        }) as @{collectionName})\n
				      }\n
				    }
			@else{}
				null
			@end{}
		@else{eventKind == API}
			new Handler<@{eventType.erased.name}>() {\n
			      public void handle(@{eventType.erased.name} event) {\n
			        @{param.name}.handle(new @{eventType.erased.simpleName}(event));\n
			      }\n
			    }
		@else{eventKind == ASYNC_RESULT}
			@code{resultType=eventType.args[0]}
			@code{resultKind=resultType.kind}
			@if{resultKind == OTHER || resultKind.basic || resultKind == VOID}
				@{param.name}
			@else{resultKind == LIST || resultKind == SET}
				@code{elementType=resultType.args[0]}
				@code{elementKind=elementType.kind}
				@if{elementKind == PRIMITIVE || elementKind == BOXED_PRIMITIVE || elementKind == STRING}
					@{param.name}
				@else{elementKind == API || elementKind.json}
					@code{collectionName=resultType.raw.simpleName}
					@if{elementKind == API}
						@code{toGroovyElement='new ' + elementType.simpleName + '(element)'}
						@code{elementJavaType=elementType.name}
						@code{elementGroovyType=elementType.simpleName}
					@else{elementKind == JSON_OBJECT}
						@code{toGroovyElement='element.toMap()'}
						@code{elementJavaType='JsonObject'}
						@code{elementGroovyType='Map<String, Object>'}
					@else{}
						@code{toGroovyElement='element.toList()'}
						@code{elementJavaType='JsonArray'}
						@code{elementGroovyType='List<Object>'}
					@end{}
					@code{eventJavaType=collectionName + '<' + elementJavaType + '>'}
					@code{eventGroovyType=collectionName + '<' + elementGroovyType + '>'}
					@code{callbackObject='event.result().collect({\n            ' + elementType.name + ' element ->\n            ' + toGroovyElement + '\n          }) as ' + collectionName}
					@includeNamed{'resultHandlerTemplate';eventJavaType=eventJavaType;eventGroovyType=eventGroovyType;callbackObject=callbackObject;callbackName=param.name}
				@else{}
					null
				@end{}
			@else{resultKind == JSON_OBJECT}
				@includeNamed{'resultHandlerTemplate';eventJavaType=resultType.name;eventGroovyType='Map<String, Object>';callbackObject='event.result().toMap()';callbackName=param.name}
			@else{resultKind == JSON_ARRAY}
				@includeNamed{'resultHandlerTemplate';eventJavaType=resultType.name;eventGroovyType='List<Object>';callbackObject='event.result().toList()';callbackName=param.name}
			@else{resultKind == OBJECT}
				@includeNamed{'resultHandlerTemplate';eventJavaType='Object';eventGroovyType='Object';callbackObject='InternalHelper.wrapObject(event.result())';callbackName=param.name}
			@else{resultKind == API}
				@comment{'Workaround for https://jira.codehaus.org/browse/GROOVY-6977 : Message<R> -> Message'}
				@code{resultType=resultType.erased}
				@includeNamed{'resultHandlerTemplate';eventJavaType=resultType.name;eventGroovyType=resultType.simpleName;callbackObject='new ' + resultType.simpleName + '(event.result())';callbackName=param.name}
			@else{}
				null /* Handler<AsyncResult<@{resultType.name}>> with kind @{resultKind} not yet implemented */
			@end{}
		@else{eventKind == OBJECT}
			new Handler<Object>() {\n
			      public void handle(Object event) {\n
			        @{param.name}.handle(InternalHelper.wrapObject(event))\n
			      }\n
			    }
		@else{}
			null /* Handler<@{eventType.name}> with kind @{eventKind} not yet implemented */
		@end{}
	@else{}
		@{param.name}
	@end{}
@end{}

@declare{'returnTypeTemplate'}
	@if{type.kind == JSON_OBJECT}
		Map<String, Object>
	@else{type.kind == JSON_ARRAY}
		List<Object>
	@else{}
		@{type.simpleName}
	@end{}
@end{}

@comment{"Generate the imports"}
@foreach{importedType:importedTypes}
	@if{importedType.kind == API}
		@if{!ifacePackageName.equals(importedType.packageName)}
			import @{importedType.toString().replace("io.vertx.", "io.vertx.java.")}\n
		@end{}
	@else{}
		@if{!importedType.packageName.equals("java.lang")}
			import @{importedType}\n
		@end{}
	@end{}
@end{}

@if{ifaceComment != null}
/**\n
 *@{ifaceComment.replaceAll('\n(?!$)', '\n *')}
 */\n
@end{}
public @if{concrete}class@else{}interface@end{} @{helper.getSimpleName(ifaceFQCN)}

@if{concrete}
	@if{concreteSuperTypes.size() > 0}
	 extends
		@foreach{concreteSuperType: concreteSuperTypes}
		 @{concreteSuperType.simpleName}
		@end{}
	@end{}
@end{}

@if{abstractSuperTypes.size() > 0}
	 @if{concrete}implements@else{}extends@end{}
	@foreach{abstractSuperType: abstractSuperTypes}
	 @{abstractSuperType.simpleName}
	@end{', '}
@end{} {\n

@if{concrete}

	  final def @{helper.getNonGenericType(ifaceFQCN)} delegate;\n
	  public @{ifaceSimpleName}(@{helper.getNonGenericType(ifaceFQCN)} delegate) {\n
	@if{concrete && concreteSuperTypes.size() > 0}
	    super(delegate);\n
	@end{}
	    this.delegate = delegate;\n
	  }\n

	  public @{ifaceFQCN} getDelegate() {\n
	    return delegate;\n
	  }\n

	@foreach{method:methods}
	@if{method.comment != null}
	  /**\n
	   *@{method.comment.replaceAll('\n(?!$)', '\n   *')}
	   */\n
	@end{}
	  public @if{method.staticMethod}static @end{}@if{method.typeParams.size() > 0}<@foreach{typeVar:method.typeParams}@{typeVar}@end{', '}> @end{}@includeNamed{'returnTypeTemplate';type=method.returnType} @{method.name}(@foreach{param: method.params}@includeNamed{'paramTemplate';param=param}@end{', '}) {\n
	@if{method.fluent}
	    @includeNamed{'invokeDelegate';method:method};\n
	    return this;\n
	@else{method.returnType.name.equals('void')}
	    @includeNamed{'invokeDelegate';method:method};\n
	@else{}
		@if{method.cacheReturn}
		    if (cached_@{cacheDecls.size()} != null) {\n
		      return cached_@{cacheDecls.size()};\n
		    }\n
		@end{}
		@if{method.returnType.kind == OBJECT}
			@code{cachedType=method.returnType.simpleName}
		    def ret = @includeNamed{'invokeDelegate';method:method};\n
		    if (ret instanceof io.vertx.core.json.JsonObject) {\n
		      ret = (@{method.returnType.simpleName}) ((io.vertx.core.json.JsonObject) ret).toMap();\n
		    } else if (ret instanceof io.vertx.core.json.JsonArray) {\n
		      ret = (@{method.returnType.simpleName}) ((io.vertx.core.json.JsonArray) ret).toList();\n
		    }\n
		@else{method.returnType.kind == JSON_OBJECT}
			@code{cachedType='Map<String, Object>'}
		    def ret = @includeNamed{'invokeDelegate';method:method}.toMap();\n
		@else{method.returnType.kind == JSON_ARRAY}
			@code{cachedType='List<Object>'}
		    def ret = @includeNamed{'invokeDelegate';method:method}.toList();\n
		@else{!method.returnType.name.startsWith('io.vertx.')}
			@code{cachedType=method.returnType.name}
		    def ret = @includeNamed{'invokeDelegate';method:method};\n
		@else{}
			@code{cachedType=method.returnType.simpleName}
		    def ret= new @{method.returnType.simpleName}(@includeNamed{'invokeDelegate';method:method});\n
		@end{}
		@if{method.cacheReturn}
		    cached_@{cacheDecls.size()} = ret;\n
			@code{cacheDecls.add('private' + (method.staticMethod ? ' static' : '') + ' ' + cachedType + ' cached_' + cacheDecls.size())}
		@end{}
		    return ret;\n
		@end{}
	  }\n
	@end{}

@else{}

	  @{ifaceFQCN} getDelegate();\n

	@foreach{method:methods}
	  @if{method.staticMethod}static @end{}@if{method.typeParams.size() > 0}<@foreach{typeVar:method.typeParams}@{typeVar}@end{}> @end{}@{method.returnType.simpleName} @{method.name}(@foreach{param: method.params}@includeNamed{'paramTemplate';param=param}@end{', '});\n
	@end{}

@end{}

@foreach{cacheDecl:cacheDecls}
  @{cacheDecl};\n
@end{}

}\n